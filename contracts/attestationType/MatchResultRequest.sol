// SPDX-License-Identifier: MIT
pragma solidity >=0.7.6 <0.9;

///////////////////////////////////////////////////////////////////
// DO NOT CHANGE Request and Response definitions!!!
///////////////////////////////////////////////////////////////////

/**
* Verification logic description:
* 1. The RequestBody uses three parameters to get the response.
*   - uid: Unique identifier of a match. It is generated as the Keccak256 hash of the match data.
*   - requestNumber: Request sequential number. It is used to easily match request and response.
*   - requestQuery: REST-based query to the API to get the results.
*   
*Uid (32 bytes) is a unique identifier of a match. It is generated as the Keccak256 hash of the match data.
*  The data included in the hash is the following:
*  1. Match title. This title includes:
*     1. "Gender" - Whether the match is from "Men" or "Women"
*     2. "Match group" - Whether the match is from "Group A", "Group B", ... "SemiFinal, Final"
*     3. "Match teams" - e.g., "Germany vs Japan"
*  2. Match start date. The date is in the EPOCH format.
*  3. Match sport. The sport is an enum index defined by the enum of sports.
*
*The same uid logic is used by the APIs providing the match data. The data from the API is used to store the match data on the blockchain.
*This logic provides the same unique identifier for the match data in both the blockchain and the API.
*
*The ResponseBody uses four parameters to get the response:
*   - result: Possible return values are 1 = team 1 won, 2 = team 2 won, 3 = draw
*   - requestNumber: Request sequential number. It is used to easily match request and response.
*   - resultHash: Hash of the result
*   - uid: Unique identifier of a match. The same uid as used in the request.
*
*The result hash is generated with the Keccak256 hash of the result data. The data included in the hash is the following:
*  1. Match uid: Unique identifier of a match. The same uid as used in the request.
*  2. Match request number: Request sequential number. It is used to easily match request and response.
*  3. Match result: Possible return values are 0 = no data, 1 = team 1 won, 2 = team 2 won, 3 = draw
*
*Verification logic
*
*The verification logic has the following sequence:
*  1. The requestQuery data from the request is used to get the data from the selected API. The API returns the match result data.
*  2. The match result data is first validated against the uid. The uid must be a part of the match result data returned by the API.
*  3. If uid is not returned, the validation fails.
*  4. The next validation is against the hash. The hash is generated with the Keccak256 hash in the API implementation of the function:
*        keccak256(abi.encodePacked(uid, requestNumber, result));
*  5. The API will return the result hash. The result hash is compared with the hash generated by the validator. If the hashes are not the same, the validation fails.
*  6. If all validations are OK, the result is returned. This result is considered final.
*  7. When validations against multiple API's are called. The result is considered final when the data from all the API's is the same.
*
*
*Response data is a direct representation of what the API returns. The API will return:
*   - uid: Unique identifier of a match. The same uid as used in the request.
*   - result: Possible return values are 0 = no data, 1 = team 1 won, 2 = team 2 won, 3 = draw
*   - requestNumber: Request sequential number. It is used to easily match request and response.
*   - resultHash: Hash of the result
*
** Example:
*
** Request:
*  - uid: 0x123
*  - requestNumber: 1
*  - requestQuery: "https://api.com/match/0x123"
*
** Response:
*  - uid: 0x123
*  - result: 1
*  - requestNumber: 1
*  - resultHash: 0x456
* *  
* * 
* */



/**
 * @custom:name MatchResultRequest
 * @custom:id 0x07
 * @custom:supported WEB
 * @author Kalmia
 * @notice Returns the result for specified game UUID.
 * @custom:verification Result is returned from the oi-flare-proxy API.
 * @custom:lut `0xffffffffffffffff` ($2^{64}-1$ in hex)
 */
interface MatchResultRequest {
    /**
     * @notice Toplevel request
     * @param attestationType ID of the attestation type.
     * @param sourceId ID of the data source.
     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.
     * @param requestBody Data defining the request. Type (struct) and interpretation is determined by the `attestationType`.
     */
    struct Request {
        bytes32 attestationType;
        bytes32 sourceId;
        bytes32 messageIntegrityCode;
        RequestBody requestBody;
    }

    /**
     * @notice Toplevel response
     * @param attestationType Extracted from the request.
     * @param sourceId Extracted from the request.
     * @param votingRound The ID of the State Connector round in which the request was considered.
     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.
     * @param requestBody Extracted from the request.
     * @param responseBody Data defining the response. The verification rules for the construction of the response body and the type are defined per specific `attestationType`.
     */
    struct Response {
        bytes32 attestationType;
        bytes32 sourceId;
        uint64 votingRound;
        uint64 lowestUsedTimestamp;
        RequestBody requestBody;
        ResponseBody responseBody;
    }

    /**
     * @notice Toplevel proof
     * @param merkleProof Merkle proof corresponding to the attestation response.
     * @param data Attestation response.
     */
    struct Proof {
        bytes32[] merkleProof;
        Response data;
    }

    /**
     * @notice Request body for MatchResultRequest attestation type
     * @param uid unique indentifier of a match
     * @param requestNumber request sequential number
     * @param requestQuery API endpoint query to get the match result
     */
    struct RequestBody {
        bytes32 uid;
        uint256 requestNumber;
        string requestQuery;
    }

    /**
     * @notice Response body for MatchResultRequest attestation type.
     * @param result Possible return values are 0 = no data, 1 = team 1 won, 2 = team 2 won, 3 = draw
     * @param requestNumber request sequential number
     * @param resultHash hash of the result
     */
    struct ResponseBody {
        bytes32 uid;
        uint8 result;
        uint256 requestNumber;
        bytes32 resultHash;
    }
}
